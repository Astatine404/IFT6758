# -*- coding: utf-8 -*-
"""Copy of Prog-4

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YfyOYSVFGTEnvU_o4sQz_htx5eihvUKk

<center><h1> IFT-6758  </h1></center>
<center><h1> Data Science / Science des données  </h1></center> 
<center><h2> Fall-2021 </h2></center> 
<center><h3> Prog 4 </h3></center> 
<center><h3> </h3></center>

Deadline    : **Dec 22, 11.59 pm EDT** on [Gradescope](https://www.gradescope.com/courses/286503/assignments/1713200)

---

Date limite :  **Le 22 déc, 23h59 HAE** sur [Gradescope](https://www.gradescope.com/courses/286503/assignments/1713200)

**Please use only the following imports.**

**DO NOT IMPORT ANYTHING OTHER THAN SUB-PACKAGES OF THESE WHEN NECESSARY.**

This is important for running you code!

---

**Veuillez utiliser uniquement les importations suivantes.**

**N'IMPORTEZ RIEN D'AUTRE DES SOUS-PACKAGES DE CEUX-CI LORSQUE NÉCESSAIRE.**

Ceci est important pour exécuter votre code!
"""

# Commented out IPython magic to ensure Python compatibility.
#@title Imports (Run this cell first / Lancez d'abord cette cellule) { run: "auto" }

# Imports / Importations

import nltk

import sklearn

import pandas as pd
import numpy as np

import matplotlib.pyplot as plt
# %matplotlib inline

import random
import itertools
import collections

"""[4 points]

## Q1. Given a word-document matrix (words along rows and documents along columns), use SVD and obtain the dense word embeddings of the words based on a given `embedding_dimension`. Based on the `word_order` that represents the words indexed by the word-document matrix and the embeddings computed, return the word embeddings ONLY for the requested words `test_words` as a 2D numpy array. 

**[IMPORTANT: Use SVD only from numpy]**

---

## Q1. Étant donné une matrice mot-document (mots le long des lignes et documents le long des colonnes), utilisez SVD et obtenez les plongements de mots denses des mots sur la base d'une `embedding_dimension` donnée. Sur la base du `word_order` qui représente les mots indexés par la matrice word-document et les plongements calculés, retournez les plongements de mots UNIQUEMENT pour les mots demandés `test_words` sous forme d'array numpy 2D.

**[IMPORTANT: Utilisez le SVD seulement du numpy]**


"""

!wget https://github.com/ift-6758/files/raw/main/word-doc-matrix.npy
!wget https://github.com/ift-6758/files/raw/main/word-order.npy

word_doc_matrix = np.load('word-doc-matrix.npy')
word_order = list(np.load('word-order.npy'))

def q1(data_matrix = word_doc_matrix, word_order = word_order, embedding_dimension=16, test_words = ['wine', 'alarm','smile','jazz']):

  assert len(data_matrix) == len(word_order)

  """
  Your solution / Votre solution
  """

  u, s, vh = np.linalg.svd(data_matrix)
  embed_matrix = u @ np.diag(s)[:, :embedding_dimension]
  word_order = np.array(word_order)
  
  #Search indices of test_words in word_order
  word_ind = np.array([])
  for word in test_words:
    word_ind = np.concatenate((word_ind, np.where(word_order == word)[0]))

  word_ind = word_ind.astype('int32')

  test_word_embeddings = embed_matrix[word_ind, :]

  assert len(test_word_embeddings) == len(test_words)

  return test_word_embeddings 

q1()

"""[4 points]

## Q2. Given a list of sentences and a `test_word`, train a [Word2Vec](https://radimrehurek.com/gensim/auto_examples/tutorials/run_word2vec.html) model using the given specifications and return the words `most_similar`, `most_dissimilar` and `neutral` words as described below:

**Specifications**

* `sentences` - A list of tokenized sentences to use for constructing the Word2Vec vectors
* `context_length` - length of the window to generate training data for the Word2Vec model 
* `embedding_type` - Could be either 'skipgram' or 'cbow'

No other preprocessing required. 

Only fill in the line with `...`

Do not change any other parameters! 

**Return**

Use the Word2Vc `model` to determine the following words :

* `most_similar` - word most similar to the given `test_word`
* `most_dissimilar` - word most dissimilar (or most negatively similar) to the given `test_word`
* `neutral` - word that is most similar to the sum of the word vectors corresponding to the determined `most_similar` and `most_dissimilar`

Example return: `'happy','sad','meh'`

---

## Q2.Étant donné une liste de phrases et un `test_word`, entraînez un modèle [Word2Vec](https://radimrehurek.com/gensim/auto_examples/tutorials/run_word2vec.html) en utilisant les spécifications données et retournez les mots `most_similar`, `most_dissimilar` et `neutral` comme décrit ci-dessous :

**Précisions**

* `sentences` - Une liste de phrases tokenisées à utiliser pour construire les vecteurs Word2Vec
* `context_length` - longueur de la fenêtre pour générer des données d'entraînement pour le modèle Word2Vec
* `embedding_type` - Peut être 'skipgram' ou 'cbow'


Aucun autre prétraitement requis.

Remplissez uniquement la ligne avec `...`

Ne modifiez aucun autre paramètre !


**Retour**

Utilisez le `modèle` Word2Vc pour déterminer les mots suivants :

* `most_similar` - mot le plus similaire au `test_word` donné
* `most_dissimilar` - mot le plus différent (ou le plus négativement similaire) au `test_word` donné
* `neutral` - mot qui est le plus similaire à la somme des vecteurs de mots correspondant aux `most_similar` et `most_dissimilar` déterminés

Exemple de retour : `'heureux','triste','meh'`
"""

from gensim.models import Word2Vec
from nltk.corpus import treebank

nltk.download('treebank')

def q2(sentences=treebank.sents(), context_length=3, embedding_type='skipgram', test_word='social'):

  # Checking for valid values of arguments / Vérification des valeurs valides des arguments
  assert embedding_type in ['skipgram','cbow']

  """
  Your solution / Votre solution
  """

  # 
  sg = int(embedding_type == 'skipgram')
  model = Word2Vec(sentences=sentences, window=context_length, sg=sg) # To be completed / À compléter
  
  most_similar = model.wv.most_similar(positive=[test_word], topn=1)[0][0]

  most_dissimilar = model.wv.most_similar(negative=[test_word], topn=1)[0][0]

  neutral = model.wv.similar_by_vector(model.wv[most_similar] + model.wv[most_dissimilar], topn=1)[0][0]

  return most_similar, most_dissimilar, neutral

q2()

"""[7 points]

##Q3. Given a graph adjacency matrix $A$, perform random walks on the graph from each node $w$ times with length of the walk equal to $l$ and generate an embedding matrix based on the average of visit counts of each node visited during the walks.

* The order of nodes indexed by the position is the order of nodes in adjacency matrix $A$
* During the random walk, each node $v_i$ has an equal probability of $1/degree(v_i)$ of visiting an adjacent node (random seed is set as 6758).
* The embedding of each node $v_i$ is actually the average visit count over the $w$ walks for each of the $l$ nodes visited in the random walk starting from $v_i$
* The returned embedding matrix  (numpy array) should contain the node embeddings of all nodes (Each row $i$ is a node embedding of the respective node $i$)
* Please do not change the random seed as it controls the order of nodes in the random walks.


Given below is an illustration of the computation of the node embedding for node 0, the same applies for all nodes:

For $A = \begin{pmatrix} 
0 & 1 &1 &1 &1\\
1 & 0 &1 &1 &1\\
1 & 1 &0 &1 &1\\
1 & 1 &1 &0 &1\\
1 & 1 &1 &1 &0\\
\end{pmatrix},  ~l=4 \text{ and } w=2$

For node 0 that is connected to all other nodes 1, 2, 3 and 4 obtaining $w=2$ number of $l=4$ step random walks:
* $0 → 1 → 2 → 3$ which gives a visit count vector `[1,1,1,1,0]` since 0,1 and 3 are visited once each.
* $0 → 4 → 2 → 4$ which gives a visit count vector `[1,0,1,0,2]` since 0 and 2 are visited once while 4 is visited twice.

Averaging the above two visit count vectors gives `[1.0,0.5,1.0,0.5,1.0]` for node 0.


---

##Q3. Étant donné une matrice d'adjacence $A$ d'un graphe, effectuez les marches aléatoires sur le graphe de chaque nœud $w $ fois avec une longueur de la marche égale à $l$ et générer une matrice de plongement basée sur la moyenne des nombres de visites de chaque nœud visité pendant les marches.

* L'ordre des nœuds indexés par la position est l'ordre des nœuds dans la matrice d'adjacence $A$
* Au cours de la marche aléatoire, chaque nœud $v_i$ a une probabilité égale de $1/degree(v_i)$ de visiter un nœud adjacent (la graine aléatoire `seed` est fixée à 6758).
* Le plongement de chaque nœud $v_i$ est en fait le nombre moyen de visites sur les $w$ marches pour chacun des $l$ nœuds visités dans la marche aléatoire à partir de $v_i$
* La matrice de plongement retourné (array numpy) doit contenir les plongements de nœuds de tous les nœuds (chaque ligne $i$ est un plongement de nœud du nœud respectif $i$)
* Veuillez ne pas modifier la graine aléatoire car elle contrôle l'ordre des nœuds dans les marches aléatoires.


Ci-dessous, une illustration du calcul du plongement des nœuds pour le nœud 0, il en va de même pour tous les nœuds :

Pour $A = \begin{pmatrix}
0 & 1 &1 &1 &1\\
1 & 0 &1 &1 &1\\
1 & 1 &0 &1 &1\\
1 & 1 &1 &0 &1\\
1 & 1 &1 &1 &0\\
\end{pmatrix}, ~l=4 \text{ et } w=2$

Pour le nœud 0 qui est connecté à tous les autres nœuds 1, 2, 3 et 4 obtenant $w=2$ nombre de marches aléatoires $l=4$ pas :
* $0 → 1 → 2 → 3$ qui donne un vecteur de nombre de visites `[1,1,1,1,0]` puisque 0,1, 2 et 3 sont visités une fois chacun.
* $0 → 4 → 2 → 4$ qui donne un vecteur de nombre de visites `[1,0,1,0,2]` puisque 0 et 2 sont visités une fois tandis que 4 est visité deux fois.

La moyenne des deux vecteurs de nombre de visites ci-dessus donne `[1.0,0.5,1.0,0.5,1.0]` pour le nœud 0.
"""

!wget https://github.com/ift-6758/files/raw/main/graph-adjacency-matrix.npy

random.seed(6758)
np.random.seed(6758)
adjacency_matrix = np.load('graph-adjacency-matrix.npy')

def q3(A = adjacency_matrix, l=5, w=5):
  """
  Your solution / Votre solution
  """
  n_nodes = A.shape[0]
  
  node_embeddings = []
  for start_node in range(n_nodes):
    walks = []
    for walk_no in range(w):
      curr_node = start_node
      visits = np.zeros((n_nodes,))
      visits[curr_node] += 1
      for step in range(l-1):
        adj_nodes = []
        # Check adjacents of curr_node
        for adj_node in range(n_nodes):
          if A[curr_node][adj_node] > 0:
            adj_nodes.append(adj_node)
        # Choose random adj node
        curr_node = adj_nodes[random.randrange(0, len(adj_nodes))]
        visits[curr_node] += 1
      walks.append(visits)
    node_embeddings.append(np.array(walks).mean(axis=0))


  #node_embeddings = np.array([[]])
  node_embeddings = np.array(node_embeddings)

  assert len(node_embeddings) == len(adjacency_matrix)

  return node_embeddings

q3()

"""[5 points]

#Q4. Given a node embedding matrix that contains a node embedding vector for each node, finds the most similar node for each node in the graph. Assume that the node indexes start from $0,..., n-1$ where $n$ is the number of nodes.                                                                                    

For example : For a given $5 \times 20$ embedding matrix corresponding to 20-dimensional embeddings of the 5 nodes `[0,1,2,3,4]`, `most_similar_node_list` could be `[4,3,4,1,2]` indicating that 4 is the most similar node 0, 3 is the most similar node to 1, 4 is the most similar node to 2 and so on.

---

#Q4. Étant donné une matrice de plongement de nœuds contenant un vecteur de plongement de nœuds pour chaque nœud, recherche le nœud le plus similaire pour chaque nœud du graphe. Supposons que les index de nœuds commencent à $0,..., n-1$ où $n$ est le nombre de nœuds.

Par exemple : Pour une matrice de plongement donnée de $5 \times 20$ correspondant aux plongements en 20 dimensions de 5 nœuds `[0,1,2,3,4]`, `most_similar_node_list` pourrait être `[4,3,4,1,2]` indiquant que 4 est le nœud le plus similaire à 0, 3 est le nœud le plus similaire à 1, 4 est le nœud le plus similaire à 2 et ainsi de suite.

"""

!wget https://github.com/ift-6758/files/raw/main/node-embeddings.npy

node_embeddings = np.load('node-embeddings.npy')

def q4(embedding_matrix = node_embeddings):

    """
    Your solution / Votre solution
    """

    most_similar_node_list = list()

    for node in range(embedding_matrix.shape[0]):
      max_similarity = -np.inf
      most_similar = None
      for node_ in range(embedding_matrix.shape[0]):
        if node == node_:
          continue
        similarity = np.dot(embedding_matrix[node, :], embedding_matrix[node_, :]) / (np.linalg.norm(embedding_matrix[node, :]) * np.linalg.norm(embedding_matrix[node_, :]))
        if similarity > max_similarity:
          most_similar = node_
          max_similarity = similarity
      most_similar_node_list.append(most_similar)


    # Convert to list if you have it as a np array / Convertissez à une liste si vous l'avez comme un array np
    if type(most_similar_node_list) != list:
      most_similar_node_list = list(most_similar_node_list)

    # Ensuring that every node has the most similar node specified / S'assurer que chaque nœud a le nœud le plus similaire spécifié
    assert len(most_similar_node_list) == len(embedding_matrix)

    return most_similar_node_list

q4()

"""Packaging all the above functions into a class for the solution file to submit on Gradescope.

---

Empaqueter toutes les fonctions ci-dessus dans une classe pour le fichier de solution à remettre sur Gradescope.
"""

class Prog4:
  
  def q1(self, data_matrix = word_doc_matrix, word_order = word_order, embedding_dimension=16, test_words = ['wine', 'alarm','smile','jazz']):
    return q1(data_matrix, word_order, embedding_dimension, test_words)
  
  def q2(self, sentences=treebank.sents(), context_length=3, embedding_type='skipgram', test_word='social'):
    return q2(sentences, context_length, embedding_type, test_word)

  def q3(self, A = adjacency_matrix, l=5, w=5):
    random.seed(6758)
    np.random.seed(6758)
    return q3(A, l, w)

  def q4(self, embedding_matrix = node_embeddings):
    return q4(embedding_matrix)

prog = Prog4()
print(prog.q1())
print(prog.q2())
print(prog.q3())
print(prog.q4())

